<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Vincent">





<title>React-Fiber | 努力每一天</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Vincent</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Vincent</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">移到底部</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "收起"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "展开"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">React-Fiber</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">六月 25, 2020&nbsp;&nbsp;16:06:46</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/React/">React</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>本文转自<a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">Richard  -  [译]深入React fiber架构及源码</a><br><a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">原文链接</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>React16 提出了 Fiber 结构，其能够将任务分片，划分优先级，同时能够实现类似于操作系统中对线程的抢占式调度，非常强大。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>React 是一个用于构建 UI 的 JavaScript 库，其核心是跟踪组件状态变化并将更新到 view 上。在 React 中，我们将此过程视为 <strong>reconciliation</strong>。在调用 setState 方法后，框架会检查 state 或 props 是否已更改并在 UI 上重新呈现组件。</p>
<p>React 的文档提供了一种更高层次的对这种机制的<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">描述</a>：包含 React 元素的作用，生命周期方法和渲染方法，以及应用于组件子元素的 diffing 算法等相关内容。从 render 方法返回的不可变 React 元素树通常称为 “Virtual DOM”。这个术语有助于早期向人们解释 React，但它也引起了歧义，并且不再在 React 文档中使用。在本文中，将坚持称它为 React 元素的树。</p>
<p>除了 React 元素的树之外，框架总是有一个用于保持状态的内部实例树 (internal instances)（组件，DOM 节点等），与之相对的是跟具体平台有关的 public instance，也被称为 Host instance 。从 React 16 开始，React 推出了该内部实例树的新实现以及负责操作树的算法，被称为 Fiber。接下来我们将了解 fiber 架构带来的优势，<a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">了解 React 在 fiber 中使用链表的方式和原因</a>。</p>
<p>这是本系列的第一篇文章，旨在教你 React 的内部架构。在本文中，我想提供其中的重要概念和以及与算法相关的数据结构。一旦我们有足够的背景，我们将探索用于遍历和处理 fiber tree 的算法和主要功能。本系列的下一篇文章将演示 React 如何使用该算法执行初始渲染和处理 state 以及 props 更新。从那里我们将继续讨论 scheduler 的详细信息，子协调过程以及构建 effect list 的机制。</p>
<h3 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h3><p>React框架在内存中维护了一个虚拟DOM树，根据数据的变化自动更新虚拟DOM，得到一个新虚拟DOM，然后通过diff算法对新老的虚拟DOM树进对比，通过对比得出变化的部分，得到一个Change(Patch)，然后将这个Patch加入列队。最终批量更新Patch到DOM中。</p>
<h3 id="React-16之前的不足"><a href="#React-16之前的不足" class="headerlink" title="React 16之前的不足"></a>React 16之前的不足</h3><p>React的工作过程。通过<code>render()</code>和<code>setState()</code>进行组的渲染和更新时，React主要有两个阶段:Reconclier,Renderer</p>
<p><b>Reconclier(调和阶段)</b></p>
<p>  React会自动向下递归，遍历新数据生成新的Virtural DOM，然后通过diff算法，找到需要变更的元素(Patch)，放到更新列队里面去。</p>
<p><b>Renderer(渲染阶段)</b></p>
<p>  遍历更新队列，通过调用宿主API(DOM，Native，WebGL)，更新渲染对应的元素。</p>
<p>在<b>协调阶段</b>，采用的是递归的遍历方式，这种方式也被成为<b><code>Stack Reconciler</code></b>，主要是为了区分<b><code>Fiber Reconciler</code></b>取得一个名字。</p>
<p><b><code>Stack Reconciler</code> 一旦任务开始进行，就无法中断，那么js将一直占用主线程，一直要等到整个虚拟DOM树计算完成才能把执行权交给渲染引擎，这样会导致用户的交互、动画等任务无法立即处理。</b></p>
<p>为了解决这个问题，把渲染更新过程中查分为多个子任务，每次只做小部分更新，等做完看是否还有<b>剩余的时间</b>，如果有继续下一个任务；如果没有，挂起当前任务,将时间控制权交给主线程，等主线程不忙的时候在继续执行。这种策略叫做<b>Cooperative Scheduling(合作式调度)</b>, 操作系统常用任务调度策略之一。</p>
<p>合作式调度任务主要是来分配任务的。当有更新任务的时候，不会立即做Diff操作，而是先把当前的更新送入一个Update Queue中，然后交给Scheduler去处理，Scheduler会根据当前主线程的使用情况去处理这次的Update。这种特性的实现，使用了<code>requestIdelCallback</code>Api。对于不支持的浏览器，React会加上pollyfill。</p>
<p>浏览器是一帧一帧执行的，在两个帧之间，主线程通常会有一小段空闲时间，<code>requestIdelCallback</code>可以在这个<b>空闲期调用空闲期回调</b>，执行一些任务。</p>
<ul>
<li>低优先级任务由<code>requestIdelCallback</code>处理；</li>
<li>高优先级的任务，如动画相关的由<code>requestAnimationFrame</code>处理；</li>
<li><code>requestIdelCallback</code>可以在多个空闲期调用空闲期回调，执行任务；</li>
<li><code>requestIdelCallback</code>方法提供 deadline，即任务执行限制时间，用来切分任务，避免长时间执行，阻塞UI渲染而导致的掉帧；</li>
</ul>
<p>实现可能遇到的问题：</p>
<ul>
<li>如何查分成子任务？</li>
<li>一个子任务多大合适？</li>
<li>怎么判断是否还有剩余时间？</li>
<li>有剩余时间怎么去调度应该执行哪一个任务？</li>
<li>没有剩余时间之前的任务该怎么办？</li>
</ul>
<h3 id="Fiber-架构就是用来解决这个问题的"><a href="#Fiber-架构就是用来解决这个问题的" class="headerlink" title="Fiber 架构就是用来解决这个问题的"></a>Fiber 架构就是用来解决这个问题的</h3><h4 id="Fiber-是什么？"><a href="#Fiber-是什么？" class="headerlink" title="Fiber 是什么？"></a>Fiber 是什么？</h4><p>Fiber是重新实现的堆栈帧，本质上Fiber可以理解为一个虚拟的堆栈帧，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染任务改成异步渲染任务。所以理解Fiber是一种数据结构(堆栈帧),也可以理解成一种解决可中断的调用任务的一种解决方案，它的特性就是时间分片(time slicing)和暂停(supense)。<br>为了做到这些，需要将一种方法将任务分解为单元，Fiber代表一种工作单元。</p>
<h4 id="Fiber是怎么工作的"><a href="#Fiber是怎么工作的" class="headerlink" title="Fiber是怎么工作的"></a>Fiber是怎么工作的</h4><ul>
<li><code>React.render()</code>和<code>setState()</code>的时候开始创建更新。</li>
<li>将创建的更新加入任务列队，等待调度。</li>
<li>在<code>requestIdelCallback</code>空闲时执行任务。</li>
<li>从根节点开始遍历 Fiber Node，并且构建WokeInProgress Tree。</li>
<li>生成 <code>EffectList</code></li>
<li>根据 <code>EffectList</code>更新DOM。</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>首先写一个非常简单的程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">            &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以查看在线<a href="https://stackblitz.com/edit/react-t4rdmh" target="_blank" rel="noopener">实例</a>。可以看到，它是一个非常简单的组件，它从 render 方法返回两个子元素 button 和 span。单击 button 后，组件的 state 将在处理程序内更新，这会导致 span 元素的文本更新。<br>React 会在 <strong>reconciliation</strong> 期间执行各种活动。例如，以下是 React 在上面这个程序中第一次渲染和状态更新之后执行的高级操作：</p>
<ol>
<li>更新 state 中的 count 属性</li>
<li>检索并比较 ClickCounter 子组件以及 props</li>
<li>更新 span 元素的 props</li>
</ol>
<p>同时，在 reconciliation 期间，还会执行其他活动包括<a href="https://zh-hans.reactjs.org/docs/react-component.html" target="_blank" rel="noopener">调用生命周期方法</a>或<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">更新引用</a>。所有这些活动在 fiber 架构中统称为 “work”。work 类型通常取决于 React 元素的类型。例如，对于 class 组件，React 需要创建实例，而不是为 function 组件执行此操作。并且，React 中有许多元素，例如：class 和 function 组件，Host 组件（DOM 节点），protals 等. React 元素的类型由 createElement 函数的第一个参数定义，此函数通常在 render 方法中用于创建元素。<strong>总结起来，就是更新组件的内部状态，触发 side-effects 执行。</strong><br>在我们开始探索 fiber 算法之前，让我们首先熟悉 React 内部使用的数据结构。</p>
<h2 id="从-React-Elements-到-Fiber-nodes"><a href="#从-React-Elements-到-Fiber-nodes" class="headerlink" title="从 React Elements 到 Fiber nodes"></a><strong>从 React Elements 到 Fiber nodes</strong></h2><p>React 中的每个组件都有一个 UI 表示，这个 UI 可以通过调用一个 view 或一个从 render 方法返回。这是 ClickCounter 组件的模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>

<h2 id="React-Elements"><a href="#React-Elements" class="headerlink" title="React Elements"></a><strong>React Elements</strong></h2><p>一旦模板通过 JSX 编译器编译，就会得到一堆 React 元素。这是从 React 组件的 render 方法返回的，而不是 HTML。由于我们不需要使用 JSX，因此我们的 ClickCounter 组件的 render 方法可以像这样重写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'button'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'1'</span>,</span><br><span class="line">                    onClick: <span class="keyword">this</span>.onClick</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'Update counter'</span></span><br><span class="line">            ),</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'span'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'2'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">this</span>.state.count</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 render 方法中调用 React.createElement 会创建两个数据结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        key: <span class="string">"1"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="string">'Update counter'</span>,</span><br><span class="line">            onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'span'</span>,</span><br><span class="line">        key: <span class="string">"2"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到 React 将 $$typeof 属性添加到这些对象，以将它们唯一地标识为 React 元素。然后我们可以通过 type，key 和 props 属性来描述元素。这些值取自传递给 React.createElement 函数的值。请注意 React 如何将文本内容表示为 span 和 button 节点的子项，以及 click 处理程序如何成为按钮元素 props 的一部分。 React 元素上还有其他字段，如 ref 字段，超出了本文的范围，不再阐述。</p>
<p>同时 ClickCouter 元素没有任何的 props 或者 key:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    ref: <span class="literal">null</span>,</span><br><span class="line">    type: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fiber-nodes"><a href="#Fiber-nodes" class="headerlink" title="Fiber nodes"></a><strong>Fiber nodes</strong></h2><p>在 reconciliation 期间，来自 render 方法返回的每个 React 元素的数据被合并到 fiber node 树中，每个 React 元素都有一个相应的 fiber node。与 React 元素不同，每次渲染过程，不会再重新创建 fiber。这些可变的数据包含组件 state 和 DOM。 我们之前讨论过，根据 React 元素的类型，框架需要执行不同的活动。在我们的示例应用程序中，对于 class 组件 ClickCounter，它调用生命周期方法和 render 方法，而对于 span Host 组件（DOM 节点），它执行 DOM 更新。因此，每个 React 元素都会转换为相应类型的 Fiber 节点，用于描述需要完成的工作。</p>
<p>可以这样认为：<strong>fiber 作为一种数据结构，用于代表某些 worker，换句话说，就是一个 work 单元，通过 Fiber 的架构，提供了一种跟踪，调度，暂停和中止工作的便捷方式。</strong></p>
<p>当 React 元素第一次转换为 fiber 节点时，React 使用 createElement 返回的数据来创建 fiber，这段代码在 <a href="https://github.com/facebook/react/blob/c1c5499cc3fd179004911b3391a55de1af4de037/packages/react-reconciler/src/ReactFiber.js#L602" target="_blank" rel="noopener">createFiberFromTypeAndProps</a> 函数中。在随后的更新中，React 重用 fiber 节点，并使用来自相应 React 元素的数据来更新必要的属性。如果不再从 render 方法返回相应的 React 元素，React 可能还需要根据 key 来移动层次结构中的节点或删除它。</p>
<p>可以查看 <a href="https://github.com/facebook/react/blob/v16.13.0/packages/react-reconciler/src/ReactChildFiber.js#L268" target="_blank" rel="noopener">ChildReconciler</a> 函数的实现，来了解 React 为现有 fiber 节点执行的所有活动和相应函数的列表。因为 React 为每个 React 元素创建了一个 fiber node，并且因为我们有一个这些元素的树，所以我们将拥有一个 fiber node tree。对于我们的示例应用程序，它看起来像这样：</p>
<p><img src="https://pic2.zhimg.com/v2-0ab001d3801fefcd634c9e0339b26545_b.jpg" alt=""></p>
<p>所有 fiber 节点都通过使用 fiber 节点上的以下属性：child，sibling 和 return 来构成一个 fiber node 的 linked list(后面我们称之为链表)。有关它为什么以这种方式工作的更多详细信息，可以查看<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><strong>Current and work in progress trees</strong></p>
<p>在第一次渲染之后，React 最终得到一个 fiber tree，它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 current tree。当 React 开始处理更新时，它会构建一个所谓的 workInProgress tree，它反映了要刷新到屏幕的未来状态。<br>所有 work 都在 workInProgress tree 中的 fiber 上执行。当 React 遍历 current tree 时，对于每个现有 fiber 节点，它会使用 render 方法返回的 React 元素中的数据创建一个备用 (alternate)fiber 节点，这些节点用于构成 workInProgress tree(备用 tree)。处理完更新并完成所有相关工作后，React 将备用 tree 刷新到屏幕。一旦这个 workInProgress tree 在屏幕上呈现，它就会变成 current tree。<br>React 的核心原则之一是一致性。 React 总是一次更新 DOM - 它不会显示部分结果。 workInProgress tree 对用户不可见，因此 React 可以先处理完所有组件，然后将其更改刷新到屏幕。</p>
<p>在源代码中，可以看到很多函数从 current tree 和 workInProgress tree 中获取 fiber 节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>每个 fiber 节点都会通过 alternate 字段保持对另一个树的对应节点的引用。current tree 中的节点指向 workInProgress tree 中的备用节点，反之亦然。</p>
<h2 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side-effects"></a><strong>Side-effects</strong></h2><p>我们可以将 React 中的一个组件视为一个使用 state 和 props 来计算 UI 的函数。每个其他活动，如改变 DOM 或调用生命周期方法，都应该被认为是 side-effects，react 文档中是这样描述的 side-effects 的：</p>
<blockquote>
<p><em>You’ve likely performed data fetching, subscriptions, or manually</em> <strong>changing the DOM 的</strong><em>from React components before. We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering.</em></p>
</blockquote>
<p>可以看到大多数 state 和 props 更新将 side-effects。由于应用 effects 是一种 work，fiber 节点是一种方便的机制，可以跟踪除更新之外的 effects。每个 fiber 节点都可以具有与之相关的 effects, 通过 fiber 节点中的 effectTag 字段表示。<br>因此，Fiber 中的 effects 基本上定义了处理更新后需要为实例完成的工作，对于 Host 组件（DOM 元素），工作包括添加，更新或删除元素。对于 class 组件，React 可能需要更新 ref 并调用 componentDidMount 和 componentDidUpdate 生命周期方法，还存在与其他类型的 fiber 相对应的其他 effects。</p>
<h2 id="Effects-list"><a href="#Effects-list" class="headerlink" title="Effects list"></a><strong>Effects list</strong></h2><p>React 能够非常快速地更新，并且为了实现高性能，它采用了一些有趣的技术。其中之一是构建带有 side-effects 的 fiber 节点的线性列表，其具有快速迭代的效果。迭代线性列表比树快得多，并且没有必要在没有 side effects 的节点上花费时间。<br>此列表的目标是标记具有 DOM 更新或与其关联的其他 effects 的节点，此列表是 finishedWork tree 的子集，并使用 nextEffect 属性，而不是 current 和 workInProgress 树中使用的 child 属性进行链接。<br>Dan Abramove 为 effecs list 提供了一个类比: 他喜欢将它想象成一棵圣诞树，“圣诞灯” 将所有带有 effects 的节点绑定在一起。为了使这个 effects list 可视化，让我们想象下面的 fiber node tree，其中<strong>橙色的节点都有一些 effects 需要处理</strong>。例如，我们的更新导致 c2 被插入到 DOM 中，d2 和 c1 被用于更改属性，而 b2 被用于激活生命周期方法。effects list 将它们链接在一起，以便 React 可以在以后跳过其他节点：</p>
<p><img src="https://pic2.zhimg.com/v2-b805de025ddf9e4c56e3ac669cea102d_b.jpg" alt="">)<img src="https://pic2.zhimg.com/v2-b805de025ddf9e4c56e3ac669cea102d_r.jpg" alt=""></p>
<p>你可以看到带有 effects 的节点是如何链接在一起的，当遍历节点时，React 使用 firstEffect 指针来确定 effects list 的开始位置。所以上图可以表示为这样的线性列表</p>
<p><img src="https://pic4.zhimg.com/v2-99b799d44b1f32c2d493ef61398ca8cf_b.png" alt="">)<img src="https://pic4.zhimg.com/v2-99b799d44b1f32c2d493ef61398ca8cf_r.jpg" alt=""></p>
<h2 id="Root-of-the-fiber-tree"><a href="#Root-of-the-fiber-tree" class="headerlink" title="Root of the fiber tree"></a><strong>Root of the fiber tree</strong></h2><p>每个 React 应用程序都有一个或多个作为 container 的 DOM 元素。在我们的例子中，它是带有 id 为 “container” 的 div 元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> domContainer = <span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>);</span><br><span class="line">ReactDOM.render(React.createElement(ClickCounter), domContainer);</span><br></pre></td></tr></table></figure>

<p>React 为每个 container 创建一个 fiber root 对象，可以使用对 DOM 元素的引用来访问它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">'#container'</span>)._reactRootContainer._internalRoot</span><br></pre></td></tr></table></figure>

<p>这个 fiber root 是 React 保存对 fiber tree 引用的地方。它存储在 fiber tree 的 current 属性中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current</span><br></pre></td></tr></table></figure>

<p>fiber tree 以特殊类型的 fiber 节点（HostRoot）开始。它是在内部创建的，并充当最顶层组件的父级，HostRoot fiber 节点通过 stateNode 属性指向 FiberRoot：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以通过 fiber root 访问最顶端的 HostRoot 的 fiber node 来探索 fiber tree。或者，可以从组件实例中获取单个 fiber 节点，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compInstance._reactInternalFiber</span><br></pre></td></tr></table></figure>

<h2 id="Fiber-node-structure"><a href="#Fiber-node-structure" class="headerlink" title="Fiber node structure"></a><strong>Fiber node structure</strong></h2><p>现在让我们看一下为 ClickCounter 组件创建的 fiber 节点的结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">    type: ClickCounter,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;&#125;,</span><br><span class="line">    memoizedProps: &#123;&#125;,</span><br><span class="line">    tag: <span class="number">1</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及 span 节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    tag: <span class="number">5</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fiber 节点上有很多字段，我在前面的部分中描述了 alternate 字段，effectTag 和 nextEffect 的用途。现在让我们看看为什么我们需要其他字段：</p>
<ul>
<li><strong>stateNode：</strong>保存对组件的类实例，DOM 节点或与 fiber 节点关联的其他 React 元素类型的引用。一般来说，可以认为这个属性用于保存与 fiber 相关的本地状态。</li>
<li><strong>type：</strong>定义与此 fiber 关联的功能或类。对于类组件，它指向构造函数；对于 DOM 元素，它指定 HTML tag。可以使用这个字段来理解 fiber 节点与哪个元素相关。</li>
<li><strong>tag：</strong>定义 fiber 的类型。它在 reconcile 算法中用于确定需要完成的工作。如前所述，工作取决于 React 元素的类型，函数 <a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js%23L414" target="_blank" rel="noopener">createFiberFromTypeAndProps</a> 将 React 元素映射到相应的 fiber 节点类型。在我们的应用程序中，ClickCounter 组件的属性标记是 1，表示 ClassComponent，而 span 元素的属性标记是 5，表示 Host Component。</li>
<li><strong>updateQueue：</strong>用于状态更新，回调函数，DOM 更新的队列</li>
<li><strong>memoizedState：</strong>用于创建输出的 fiber 状态。处理更新时，它会反映当前在屏幕上呈现的状态。</li>
<li><strong>memoizedProps：</strong>在前一次渲染期间用于创建输出的 props</li>
<li><strong>pendingProps：</strong>已从 React 元素中的新数据更新，并且需要应用于子组件或 DOM 元素的 props</li>
<li><strong>key：</strong>具有一组 children 的唯一标识符，可帮助 React 确定哪些项已更改，已添加或从列表中删除。它与此处描述的 React 的 “<a href="https://reactjs.org/docs/lists-and-keys.html%23keys" target="_blank" rel="noopener">list and key</a>” 功能有关。</li>
</ul>
<p>可以在<a href="https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js%23L78" target="_blank" rel="noopener">此处</a>找到 fiber 节点的完整结构。在上面的解释中省略了一堆字段，尤其跳过了 child，sibling 和 return，组成了树数据结构。以及特定于 Scheduler 的 expirationTime，childExpirationTime 和 mode 等字段类别。</p>
<h2 id="General-algorithm"><a href="#General-algorithm" class="headerlink" title="General algorithm"></a><strong>General algorithm</strong></h2><p>React 把一次渲染分为两个阶段：<strong>render</strong> 和 <strong>commit</strong>。</p>
<p>在 render 阶段时，React 通过 setState 或 React.render 来执行组件的更新，并确定需要在 UI 中更新的内容。如果是第一次渲染，React 会为 render 方法返回的每个元素，创建一个新的 fiber 节点。在接下来的更新中，将重用和更新现有 React 元素的 fiber 节点。render 阶段的结果是<strong>生成一个部分节点标记了 side effects 的 fiber 节点树</strong>，side effects 描述了在下一个 commit 阶段需要完成的工作。在此阶段，React 采用标有 side effects 的 fiber 树并将其应用于实例。它遍历 side effects 列表并执行 DOM 更新和用户可见的其他更改。</p>
<p>一个很重要的点是，<strong>render 阶段可以异步执行</strong>。 React 可以根据可用时间来处理一个或多个 fiber 节点，然后停止已完成的工作，并让出调度权来处理某些事件。然后它从它停止的地方继续。但有时候，它可能需要丢弃完成的工作并再次从头。由于在 render 阶段执行的工作不会导致任何用户可见的更改（如 DOM 更新），因此这些暂停是不会有问题的。相反，在接下来的 commit 阶段始终是同步的，这是因为在此阶段执行的工作，将会生成用户可见的变化，例如， DOM 更新，这就是 React 需要一次完成它们的原因。</p>
<p>调用生命周期方法是 React 执行的一种工作。在 render 阶段调用某些方法，在 commit 阶段调用其他方法。在 render 阶段时调用的生命周期列表如下：</p>
<ul>
<li>[UNSAFE_]componentWillMount (已废弃)</li>
<li>[UNSAFE_]componentWillReceiveProps (已废弃)</li>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>[UNSAFE_]componentWillUpdate (已废弃)</li>
<li>render</li>
</ul>
<p>可以看到，在 render 阶段执行的一些遗留生命周期方法在 react 16.3 中标记为 UNSAFE。它们现在在文档中称为遗留生命周期，将在未来的 16.x 版本中弃用，而没有 UNSAFE 前缀的版本将在 17.0 中删除。可以在此处详细了解这些<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">更改以及建议的迁移路径</a>。</p>
<p>为什么会废弃这些声明周期函数呢呢？</p>
<p>因为在 render 阶段不会产生像 DOM 更新这样的副作用，所以 React 可以异步处理与组件异步的更新（甚至可能在多个线程中执行）。然而，标有 UNSAFE 的生命周期经常被误解和滥用，开发人员倾向于将带有副作用的代码放在这些方法中，这可能会导致新的异步渲染方法出现问题。虽然只有没有 UNSAFE 前缀的副本会被删除，但它们仍然可能在即将出现的 concurrent 模式中引起问题。</p>
<p>以下是 commit 阶段执行的生命周期方法列表：</p>
<ul>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因为这些方法在同步 commit 阶段执行，所以它们可能包含副作用并获取 DOM。<br><strong>Render 阶段</strong></p>
<p>reconciliation 算法始终使用 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js%23L1132" target="_blank" rel="noopener">renderRoot</a> 函数从最顶端的 HostRoot fiber 节点开始。但是，React 会跳过已经处理过的 fiber 节点，直到找到未完成工作的节点。例如，如果在组件树中调用 setState，则 React 将从顶部开始，但会快速跳过父节点，直到它到达调用了 setState 方法的组件。</p>
<p><strong>Main steps of the work loop</strong></p>
<p>所有 fiber 节点都在 <a href="https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js%23L1136" target="_blank" rel="noopener">work loop</a> 中处理。这是循环的同步部分的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，nextUnitOfWork 从 workInProgress 树中保存对 fiber 节点 (这些节点有部分任务要处理) 的引用。当 React 遍历 Fibers 树时，它使用此变量来知道是否有任何其他 fiber 节点具有未完成的工作。处理当前 fiber 后，变量将包含对树中下一个 fiber 节点的引用或 null。在这种情况下，React 退出工作循环并准备提交更改.</p>
<p>有 4 个主要功能用于遍历树并启动或完成工作:</p>
<ul>
<li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js%23L1056" target="_blank" rel="noopener">performUnitOfWork</a></li>
<li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js%23L1489" target="_blank" rel="noopener">beginWork</a></li>
<li><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js%23L879" target="_blank" rel="noopener">completeUnitOfWork</a></li>
<li><a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js%23L532" target="_blank" rel="noopener">completeWork</a></li>
</ul>
<p>要演示如何使用它们，请查看以下遍历 fiber 树的动画。已经在演示中使用了这些函数的简化实现。每个函数都需要一个 fiber 节点进行处理，当 React 从树上下来时，可以看到当前活动的 fiber 节点发生了变化，可以清楚地看到算法如何从一个分支转到另一个分支。它首先完成 child 节点的工作，然后转移到 parent 身边.</p>
<p><img src="https://pic2.zhimg.com/v2-4d6d43020835a41fd20492f29aea1a41_b.gif" alt=""></p>
<blockquote>
<p>注意，垂直连接表示 sibling，而弯曲的连接表示 child，例如 b1 没有 child，而 b2 有一个 child c1.</p>
</blockquote>
<p>这是<a href="https://vimeo.com/302222454" target="_blank" rel="noopener">视频的链接</a>，您可以在其中暂停播放并检查当前节点和功能状态，可以简单的看到，这里适用的树遍历算法是<strong>深度优先搜索 (DFS)</strong></p>
<p>让我们从前两个函数 performUnitOfWork 和 beginWork 开始:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        next = completeUnitOfWork(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'work performed for '</span> + workInProgress.name);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performUnitOfWork 函数从 workInProgress 树接收 fiber 节点，并通过调用 beginWork 函数启动工作，即通过这个函数启动 fiber 需要执行的所有活动。出于演示的目的，我们只需记录 fiber 的名称即可表示已完成工作。beginWork 函数始终返回要在循环中处理的下一个子节点的指针或 null.</p>
<p>如果有下一个子节点，它将被赋值给 workLoop 函数中的 nextUnitOfWork 变量。但是，如果没有子节点，React 知道它到达了分支的末尾，因此它就完成当前节点。一旦节点完成，它将需要为兄弟节点执行工作并在此之后回溯到父节点。这是在 completeUnitOfWork 函数中完成的.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">        <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">        nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a sibling, return it</span></span><br><span class="line">            <span class="comment">// to perform work for this sibling</span></span><br><span class="line">            <span class="keyword">return</span> siblingFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there's no more work in this returnFiber,</span></span><br><span class="line">            <span class="comment">// continue the loop to complete the parent.</span></span><br><span class="line">            workInProgress = returnFiber;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We've reached the root.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'work completed for '</span> + workInProgress.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数的重点是一个很大的循环。当 workInProgress 节点没有子节点时，React 会进入此函数。完成当前 fiber 的工作后，它会检查是否有兄弟节点；如果找到，React 退出该函数并返回指向兄弟节点的指针。它将被赋值给 nextUnitOfWork 变量，React 将从这个兄弟开始执行分支的工作。重要的是要理解，在这一点上，React 只完成了前面兄弟姐妹的工作。它尚未完成父节点的工作，只有在完成所有子节点工作后，才能完成父节点和回溯的工作.</p>
<p>从实现中可以看出，performUnitOfWork 和 completeUnitOfWork 主要用于迭代目的，而主要活动则在 beginWork 和 completeWork 函数中进行。在后面的部分，我们将了解当 React 进入 beginWork 和 completeWork 函数时，ClickCounter 组件和 span 节点会发生什么.</p>
<p><strong>Commit phase</strong></p>
<p>该阶段以 completeRoot 函数开始，这是 React 更新 DOM 并调用 mutation 生命周期方法的地方。<br>当 React 进入这个阶段时，它有 2 棵树和 effects list。第一棵树是 current tree, 表示当前在屏幕上呈现的状态，然后是在渲染阶段构建了一个备用树，它在源代码中称为 finishedWork 或 workInProgress，表示需要在屏幕上反映的状态。此备用树通过子节点和兄弟节点指针来与 current 树类似地链接。<br>然后，有一个 effects list - 通过 nextEffect 指针链接的，finishedWork 树中节点的子集。请记住，effects list 是 render 阶段运行的结果。render 阶段的重点是确定需要插入，更新或删除哪些节点，以及哪些组件需要调用其生命周期方法，其最终生成了 effects list，也正是在提交阶段迭代的节点集。</p>
<p>出于调试目的，可以通过 fiber root 的 current 属性访 current tree，可以通过 current tree 中 HostFiber 节点的 alternate 属性访问 finishedWork 树。</p>
<p>在提交阶段运行的主要功能是 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js%23L523" target="_blank" rel="noopener">commitRoot</a>。它会执行以下操作:</p>
<ul>
<li>在标记了 Snapshot effect 的节点上使用 getSnapshotBeforeUpdate 生命周期方法</li>
<li>在标记了 Deletion effect 的节点上调用 componentWillUnmount 生命周期方法</li>
<li>执行所有 DOM 插入，更新和删除</li>
<li>将 finishedWork 树设置为 current 树</li>
<li>在标记了 Placement effect 的节点上调用 componentDidMount 生命周期方法</li>
<li>在标记了 Update effect 的节点上调用 componentDidUpdate 生命周期方法</li>
</ul>
<p>在调用 pre-mutation 方法 getSnapshotBeforeUpdate 之后，React 会在树中提交所有 side-effects。它通过两个部分：第一部分执行所有 DOM（Host）插入，更新，删除和 ref 卸载，然后，React 将 finishedWork 树分配给 FiberRoot，将 workInProgress 树标记为 current 树。前面这些都是在 commit 阶段的第一部分完成的，因此在 componentWillUnmount 中指向的仍然是前一个树，但在第二部分之前，因此在 componentDidMount / Update 中指向的是最新的树。在第二部分中，React 调用所有其他生命周期方法和 ref callback, 这些方法将会单独执行，因此已经调用了整个树中的所有放置 (placement)，更新和删除.</p>
<p>下面这段代码运行上述步骤的函数的要点，其中 root.current=finishWork 及以前为第一部分，其之后为第二部分.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">    commitBeforeMutationLifecycles()</span><br><span class="line">    commitAllHostEffects();</span><br><span class="line">    root.current = finishedWork;</span><br><span class="line">    commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些子函数中的每一个都实现了一个循环，该循环遍历 effects list 并检查 effect 的类型, 当它找到与函数功能相关的 effects 时，就会执行它.</p>
<p><strong>Pre-mutation lifecycle methods</strong></p>
<p>例如，这是在 effect tree 上迭代并检查节点是否具有 Snapshot effect 的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">            commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">        &#125;</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类组件，该 effect 意味着调用 getSnapshotBeforeUpdate 生命周期方法.</p>
<h2 id="DOM-updates"><a href="#DOM-updates" class="headerlink" title="DOM updates"></a><strong>DOM updates</strong></h2><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js%23L376" target="_blank" rel="noopener">commitAllHostEffects</a> 是 React 执行 DOM 更新的函数。该函数基本上定义了需要为节点完成并执行它的操作类型.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Update: &#123;</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">            commitDeletion(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是，React 调用 componentWillUnmount 方法作为 commitDeletion 函数中删除过程的一部分.</p>
<p>转载请注明原出处 <a href="https://zhuanlan.zhihu.com/p/57346388" target="_blank" rel="noopener">Richard  -  [译]深入React fiber架构及源码</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>版权属于:</span>
                        <span>Vincent</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>本文链接:</span>
                        <span><a href="https://wekic.com/2020/06/25/React-Fiber/">https://wekic.com/2020/06/25/React-Fiber/</a></span>
                    </p>
                    <p class="copyright-item">
                        <span>转载时须注明出处及本声明</span>
                    </p>
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/06/30/reactRefs/">React中的Refs</a>
            
            
            <a class="next" rel="next" href="/2020/06/20/javascript-EventLoop/">javascript中的事件循环</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Vincent | <a href="http://www.beian.miit.gov.cn" target="_blank">湘ICP备16003524号</a></span>
    </div>
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?db7f9055c0e4d683f78b28943eaf187a";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
        </script>
</footer>

    </div>
</body>
</html>
